<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echoes of the Quiet World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #1a1a2e;
            color: #eee;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
        }

        #instructions.fade {
            opacity: 0;
        }

        .biome-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            z-index: 99;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .biome-text.show {
            opacity: 1;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a2e;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            flex-direction: column;
            gap: 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading the Quiet World...</div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="ui">
        <div>Biome: <span id="biome">Meadow</span></div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Time: <span id="time">Dawn</span></div>
    </div>

    <div id="instructions">
        WASD / Arrow Keys - Move | Mouse - Look Around | Space - Jump<br>
        Wander freely. Listen. Feel. Discover.
    </div>

    <div id="biome-notification" class="biome-text"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <script>
        // ========== INITIALIZATION ==========
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const simplex = new SimplexNoise();

        // ========== PLAYER ==========
        const player = {
            position: new THREE.Vector3(0, 5, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { yaw: 0, pitch: 0 },
            speed: 0.15,
            jumpForce: 0.3,
            onGround: false
        };

        camera.position.copy(player.position);

        // ========== INPUT ==========
        const keys = {};
        const mouse = { x: 0, y: 0, locked: false };

        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            mouse.locked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', (e) => {
            if (mouse.locked) {
                player.rotation.yaw -= e.movementX * 0.002;
                player.rotation.pitch -= e.movementY * 0.002;
                player.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.pitch));
            }
        });

        // ========== BIOMES ==========
        const BIOMES = {
            WATER: { name: 'Water', color: 0x3498db, height: -2 },
            SAND: { name: 'Beach', color: 0xf4d03f, height: 0 },
            GRASS: { name: 'Meadow', color: 0x52b788, height: 2 },
            FOREST: { name: 'Forest', color: 0x2d6a4f, height: 4 },
            MOUNTAIN: { name: 'Mountain', color: 0x95a5a6, height: 8 },
            SNOW: { name: 'Snow Peak', color: 0xecf0f1, height: 12 }
        };

        function getBiome(height) {
            if (height < BIOMES.WATER.height) return BIOMES.WATER;
            if (height < BIOMES.SAND.height) return BIOMES.SAND;
            if (height < BIOMES.GRASS.height) return BIOMES.GRASS;
            if (height < BIOMES.FOREST.height) return BIOMES.FOREST;
            if (height < BIOMES.MOUNTAIN.height) return BIOMES.MOUNTAIN;
            return BIOMES.SNOW;
        }

        function getHeight(x, z) {
            const scale1 = 0.02;
            const scale2 = 0.05;
            const scale3 = 0.1;

            const noise1 = simplex.noise2D(x * scale1, z * scale1) * 10;
            const noise2 = simplex.noise2D(x * scale2, z * scale2) * 5;
            const noise3 = simplex.noise2D(x * scale3, z * scale3) * 2;

            return noise1 + noise2 + noise3;
        }

        // ========== WORLD GENERATION ==========
        const CHUNK_SIZE = 32;
        const RENDER_DISTANCE = 3;
        const chunks = new Map();

        class Chunk {
            constructor(x, z) {
                this.x = x;
                this.z = z;
                this.mesh = null;
                this.objects = [];
                this.generate();
            }

            generate() {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const instancedMesh = new THREE.InstancedMesh(
                    geometry,
                    new THREE.MeshLambertMaterial({ vertexColors: true }),
                    CHUNK_SIZE * CHUNK_SIZE * 16
                );

                let index = 0;
                const matrix = new THREE.Matrix4();
                const color = new THREE.Color();

                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const worldX = this.x * CHUNK_SIZE + x;
                        const worldZ = this.z * CHUNK_SIZE + z;
                        const height = Math.floor(getHeight(worldX, worldZ));
                        const biome = getBiome(height);

                        // Generate terrain
                        for (let y = -5; y <= height; y++) {
                            matrix.setPosition(worldX, y, worldZ);
                            instancedMesh.setMatrixAt(index, matrix);

                            // Color variation
                            color.setHex(biome.color);
                            if (y === height) {
                                color.multiplyScalar(0.8 + Math.random() * 0.4);
                            } else {
                                color.multiplyScalar(0.6);
                            }
                            instancedMesh.setColorAt(index, color);

                            index++;
                        }

                        // Add objects
                        if (height > 0 && Math.random() < 0.02) {
                            this.addObject(worldX, height + 1, worldZ, biome);
                        }
                    }
                }

                instancedMesh.instanceMatrix.needsUpdate = true;
                if (instancedMesh.instanceColor) {
                    instancedMesh.instanceColor.needsUpdate = true;
                }
                instancedMesh.castShadow = true;
                instancedMesh.receiveShadow = true;

                this.mesh = instancedMesh;
                scene.add(this.mesh);
            }

            addObject(x, y, z, biome) {
                const rand = Math.random();

                if (biome === BIOMES.FOREST && rand < 0.5) {
                    // Tree
                    const trunk = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 3, 0.3),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    trunk.position.set(x, y + 1.5, z);
                    trunk.castShadow = true;
                    scene.add(trunk);
                    this.objects.push(trunk);

                    const leaves = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        new THREE.MeshLambertMaterial({ color: 0x228b22 })
                    );
                    leaves.position.set(x, y + 3.5, z);
                    leaves.castShadow = true;
                    scene.add(leaves);
                    this.objects.push(leaves);
                } else if (biome === BIOMES.GRASS && rand < 0.3) {
                    // Small hut
                    const hut = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        new THREE.MeshLambertMaterial({ color: 0xd2691e })
                    );
                    hut.position.set(x, y + 1, z);
                    hut.castShadow = true;
                    scene.add(hut);
                    this.objects.push(hut);

                    // Light
                    const light = new THREE.PointLight(0xffa500, 0.5, 10);
                    light.position.set(x, y + 3, z);
                    scene.add(light);
                    this.objects.push(light);
                }
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
                this.objects.forEach(obj => {
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
            }
        }

        function getChunkKey(x, z) {
            return `${x},${z}`;
        }

        function updateChunks() {
            const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);

            const neededChunks = new Set();

            for (let x = playerChunkX - RENDER_DISTANCE; x <= playerChunkX + RENDER_DISTANCE; x++) {
                for (let z = playerChunkZ - RENDER_DISTANCE; z <= playerChunkZ + RENDER_DISTANCE; z++) {
                    const key = getChunkKey(x, z);
                    neededChunks.add(key);

                    if (!chunks.has(key)) {
                        chunks.set(key, new Chunk(x, z));
                    }
                }
            }

            // Remove far chunks
            for (const [key, chunk] of chunks.entries()) {
                if (!neededChunks.has(key)) {
                    chunk.remove();
                    chunks.delete(key);
                }
            }
        }

        // ========== LIGHTING ==========
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.015);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.6);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // ========== AUDIO SYSTEM ==========
        let audioInitialized = false;
        const synths = {};

        async function initAudio() {
            if (audioInitialized) return;
            await Tone.start();
            audioInitialized = true;

            // Ambient layers
            synths.water = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 2, decay: 1, sustain: 0.5, release: 2 }
            }).toDestination();

            synths.forest = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 1.5, decay: 0.5, sustain: 0.7, release: 1.5 }
            }).toDestination();

            synths.mountain = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 1, decay: 0.3, sustain: 0.4, release: 1 }
            }).toDestination();

            // Reverb
            const reverb = new Tone.Reverb({ decay: 5, wet: 0.3 }).toDestination();
            synths.water.connect(reverb);
            synths.forest.connect(reverb);
            synths.mountain.connect(reverb);

            // Background drone
            const drone = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 3, decay: 0, sustain: 1, release: 3 }
            }).toDestination();
            drone.volume.value = -20;

            const droneLoop = new Tone.Loop((time) => {
                drone.triggerAttackRelease('C2', '8n', time);
            }, '4n');

            Tone.Transport.start();
            droneLoop.start(0);

            // Footstep sounds
            synths.footstep = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 2,
                oscillator: { type: 'sine' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();
            synths.footstep.volume.value = -15;
        }

        let currentBiome = null;
        let lastFootstepTime = 0;

        function updateAudio() {
            if (!audioInitialized) return;

            const height = getHeight(player.position.x, player.position.z);
            const biome = getBiome(height);

            if (biome !== currentBiome) {
                currentBiome = biome;
                showBiomeNotification(biome.name);

                // Update ambient sounds
                const now = Tone.now();

                if (biome === BIOMES.WATER) {
                    synths.water.triggerAttack('C4', now);
                    synths.forest.triggerRelease(now);
                    synths.mountain.triggerRelease(now);
                } else if (biome === BIOMES.FOREST) {
                    synths.forest.triggerAttack('E4', now);
                    synths.water.triggerRelease(now);
                    synths.mountain.triggerRelease(now);
                } else if (biome === BIOMES.MOUNTAIN || biome === BIOMES.SNOW) {
                    synths.mountain.triggerAttack('G4', now);
                    synths.water.triggerRelease(now);
                    synths.forest.triggerRelease(now);
                } else {
                    synths.water.triggerRelease(now);
                    synths.forest.triggerRelease(now);
                    synths.mountain.triggerRelease(now);
                }
            }
        }

        function playFootstep() {
            if (!audioInitialized) return;
            const now = Date.now();
            if (now - lastFootstepTime > 300) {
                synths.footstep.triggerAttackRelease('C2', '16n');
                lastFootstepTime = now;
            }
        }

        // ========== UI ==========
        function showBiomeNotification(biomeName) {
            const notification = document.getElementById('biome-notification');
            notification.textContent = biomeName;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 2000);
        }

        function updateUI() {
            const height = getHeight(player.position.x, player.position.z);
            const biome = getBiome(height);
            document.getElementById('biome').textContent = biome.name;
            document.getElementById('position').textContent =
                `${Math.floor(player.position.x)}, ${Math.floor(player.position.z)}`;

            const time = (Date.now() / 100) % 100;
            const timeOfDay = time < 25 ? 'Dawn' : time < 50 ? 'Day' : time < 75 ? 'Dusk' : 'Night';
            document.getElementById('time').textContent = timeOfDay;
        }

        // Hide instructions after 5 seconds
        setTimeout(() => {
            document.getElementById('instructions').classList.add('fade');
        }, 5000);

        // ========== PHYSICS & UPDATE ==========
        function updatePlayer() {
            // Movement
            const forward = new THREE.Vector3(
                Math.sin(player.rotation.yaw),
                0,
                Math.cos(player.rotation.yaw)
            );
            const right = new THREE.Vector3(
                Math.sin(player.rotation.yaw + Math.PI / 2),
                0,
                Math.cos(player.rotation.yaw + Math.PI / 2)
            );

            let moving = false;

            if (keys['KeyW'] || keys['ArrowUp']) {
                player.velocity.add(forward.multiplyScalar(player.speed));
                moving = true;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                player.velocity.add(forward.multiplyScalar(-player.speed));
                moving = true;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.velocity.add(right.multiplyScalar(-player.speed));
                moving = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.velocity.add(right.multiplyScalar(player.speed));
                moving = true;
            }

            if (moving && player.onGround) {
                playFootstep();
            }

            // Jump
            if (keys['Space'] && player.onGround) {
                player.velocity.y = player.jumpForce;
                player.onGround = false;
            }

            // Gravity
            player.velocity.y -= 0.01;

            // Apply velocity
            player.position.add(player.velocity);

            // Collision with ground
            const groundHeight = getHeight(player.position.x, player.position.z) + 1.5;
            if (player.position.y < groundHeight) {
                player.position.y = groundHeight;
                player.velocity.y = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }

            // Damping
            player.velocity.multiplyScalar(0.85);

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotation.yaw;
            camera.rotation.x = player.rotation.pitch;
        }

        // ========== ANIMATION LOOP ==========
        let lastTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            updatePlayer();
            updateChunks();
            updateAudio();
            updateUI();

            // Animate water and fog
            const time = now * 0.0001;
            scene.fog.density = 0.015 + Math.sin(time) * 0.002;

            // Day/night cycle
            const dayTime = (now / 1000) % 100;
            const sunAngle = (dayTime / 100) * Math.PI * 2;
            sunLight.position.x = Math.cos(sunAngle) * 100;
            sunLight.position.y = Math.sin(sunAngle) * 100;

            const brightness = Math.max(0.2, Math.sin(sunAngle));
            sunLight.intensity = brightness * 0.8;
            ambientLight.intensity = brightness * 0.4;

            // Sky color
            const skyColor = new THREE.Color().setHSL(0.55, 0.7, 0.3 + brightness * 0.3);
            scene.background = skyColor;
            scene.fog.color = skyColor;

            renderer.render(scene, camera);
        }

        // ========== STARTUP ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize first chunks
        updateChunks();

        // Remove loading screen
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 1000);

        // Start audio on first interaction
        document.addEventListener('click', () => {
            if (!audioInitialized) {
                initAudio();
            }
        }, { once: true });

        // Start animation
        animate();
    </script>
</body>
</html>